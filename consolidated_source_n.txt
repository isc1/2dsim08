# === README.md ===
   1 | # === README.md ===
   2 | #2dsim08
   3 | Multithreaded creature sim
#

# === main.cpp ===
   1 | // === main.cpp ===
   2 | #include "mainwindow.h"
   3 | #include <QApplication>
   4 | 
   5 | int main(int argc, char *argv[])
   6 | {
   7 |     QApplication a(argc, argv);
   8 |     MainWindow w;
   9 |     w.show();
  10 |     return a.exec();
  11 | }
#

# === mainwindow.cpp ===
   1 | #include "mainwindow.h"
   2 | #include <QVBoxLayout>
   3 | #include <QHBoxLayout>
   4 | #include <QLabel>
   5 | #include <QPushButton>
   6 | #include <QTextEdit>
   7 | #include <QThreadPool>
   8 | #include <QRunnable>
   9 | #include <QThread>
  10 | #include <QElapsedTimer>
  11 | #include <QMutex>
  12 | #include <QMutexLocker>
  13 | #include <QMetaObject>
  14 | #include <QApplication>
  15 | #include <QRandomGenerator>
  16 | #include <QVector> // Added for QVector
  17 | // QAtomicInt is typically included via QtCore/qatomic.h or QtCore/qglobal.h
  18 | #include <algorithm>
  19 | #include <random> // For std::mt19937
  20 | #include <atomic> // For std::atomic (though one use case is replaced)
  21 | #include <iostream>
  22 | #include <iomanip>
  23 | #include <sstream>
  24 | #include <chrono>
  25 | #include <functional>
  26 | 
  27 | // Global pointer to main window for output
  28 | MainWindow* g_mainWindow = nullptr;
  29 | 
  30 | // Helper function to append text to the main window (thread-safe)
  31 | void appendToOutput(const QString& text) {
  32 |     if (g_mainWindow) {
  33 |         g_mainWindow->appendOutput(text);
  34 |     }
  35 | }
  36 | 
  37 | // === Task 1: Original Parallel Sort (Refactored to use shared pool) ===
  38 | 
  39 | class RandomGenTask : public QRunnable {
  40 | private:
  41 |     std::vector<int>* data;
  42 |     int startIndex;
  43 |     int endIndex;
  44 |     int maxValue;
  45 | 
  46 | public:
  47 |     RandomGenTask(std::vector<int>* vec, int start, int end, int maxVal = MainWindow::VECTOR_SIZE)
  48 |         : data(vec), startIndex(start), endIndex(end), maxValue(maxVal) {
  49 |         setAutoDelete(true);
  50 |     }
  51 | 
  52 |     void run() override {
  53 |         std::random_device rd;
  54 |         std::mt19937 gen(rd() ^ ( (std::mt19937::result_type)
  55 |                                  std::chrono::duration_cast<std::chrono::seconds>(
  56 |                                      std::chrono::system_clock::now().time_since_epoch()
  57 |                                  ).count() +
  58 |                                  (std::mt19937::result_type)
  59 |                                  std::hash<std::thread::id>()(std::this_thread::get_id()) ) );
  60 |         std::uniform_int_distribution<> dis(1, maxValue);
  61 | 
  62 |         for (int i = startIndex; i < endIndex; i++) {
  63 |             (*data)[i] = dis(gen);
  64 |         }
  65 |     }
  66 | };
  67 | 
  68 | class SortTask : public QRunnable {
  69 | private:
  70 |     std::vector<int>* data;
  71 |     int startIndex;
  72 |     int endIndex;
  73 |     int taskId;
  74 | 
  75 | public:
  76 |     SortTask(std::vector<int>* vec, int start, int end, int id)
  77 |         : data(vec), startIndex(start), endIndex(end), taskId(id) {
  78 |         setAutoDelete(true);
  79 |     }
  80 | 
  81 |     void run() override {
  82 |         QString startMsg = QString("[Thread %1] Task %2 sorting range [%3-%4)")
  83 |                           .arg((quintptr)QThread::currentThreadId())
  84 |                           .arg(taskId)
  85 |                           .arg(startIndex)
  86 |                           .arg(endIndex);
  87 |         appendToOutput(startMsg);
  88 | 
  89 |         std::sort(data->begin() + startIndex, data->begin() + endIndex);
  90 |         if (MainWindow::USE_PCT_CORE < 100) {
  91 |             int delayMs = (100 - MainWindow::USE_PCT_CORE) * 2;
  92 |             QThread::msleep(delayMs);
  93 |         }
  94 | 
  95 |         QString endMsg = QString("[Thread %1] Task %2 completed sorting")
  96 |                         .arg((quintptr)QThread::currentThreadId())
  97 |                         .arg(taskId);
  98 |         appendToOutput(endMsg);
  99 |     }
 100 | };
 101 | 
 102 | class MergeTask : public QRunnable {
 103 | private:
 104 |     std::vector<int>* data;
 105 |     int start1, end1;
 106 |     int start2, end2;
 107 |     int taskId;
 108 | 
 109 | public:
 110 |     MergeTask(std::vector<int>* vec, int s1, int e1, int s2, int e2, int id)
 111 |         : data(vec), start1(s1), end1(e1), start2(s2), end2(e2), taskId(id) {
 112 |         setAutoDelete(true);
 113 |     }
 114 | 
 115 |     void run() override {
 116 |         QString startMsg = QString("[Thread %1] Merge Task %2 merging ranges [%3-%4) and [%5-%6)")
 117 |                           .arg((quintptr)QThread::currentThreadId())
 118 |                           .arg(taskId)
 119 |                           .arg(start1)
 120 |                           .arg(end1)
 121 |                           .arg(start2)
 122 |                           .arg(end2);
 123 |         appendToOutput(startMsg);
 124 | 
 125 |         std::vector<int> temp;
 126 |         temp.reserve((end1 - start1) + (end2 - start2));
 127 |         std::merge(data->begin() + start1, data->begin() + end1,
 128 |                    data->begin() + start2, data->begin() + end2,
 129 |                    std::back_inserter(temp));
 130 |         std::copy(temp.begin(), temp.end(), data->begin() + start1);
 131 |         if (MainWindow::USE_PCT_CORE < 100) {
 132 |             int delayMs = (100 - MainWindow::USE_PCT_CORE) * 2;
 133 |             QThread::msleep(delayMs);
 134 |         }
 135 | 
 136 |         QString endMsg = QString("[Thread %1] Merge Task %2 completed")
 137 |                         .arg((quintptr)QThread::currentThreadId())
 138 |                         .arg(taskId);
 139 |         appendToOutput(endMsg);
 140 |     }
 141 | };
 142 | 
 143 | class ParallelSorter {
 144 | private:
 145 |     QThreadPool* m_pool;    // Declared first
 146 |     std::vector<int>* data; // Declared second
 147 | public:
 148 |     // Initializer list order matches declaration order
 149 |     ParallelSorter(std::vector<int>* vec, QThreadPool* pool) : m_pool(pool), data(vec) {
 150 |         appendToOutput(QString("ParallelSorter using shared pool with max %1 threads.").arg(m_pool->maxThreadCount()));
 151 |         appendToOutput(QString("Core utilization set to %1%").arg(MainWindow::USE_PCT_CORE));
 152 |         appendToOutput(QString("Main thread ID: %1").arg((quintptr)QThread::currentThreadId()));
 153 |     }
 154 | 
 155 |     void parallelSort() {
 156 |         int vectorSize = data->size();
 157 |         int numThreads = m_pool->maxThreadCount();
 158 |         if (numThreads == 0) {
 159 |             appendToOutput("Error: Thread pool has 0 max threads. Cannot sort.");
 160 |             return;
 161 |         }
 162 |         int chunkSize = (vectorSize > 0 && numThreads > 0) ? std::max(1, vectorSize / numThreads) : 1;
 163 | 
 164 |         appendToOutput("=== PHASE 1: Sorting chunks in parallel ===");
 165 |         appendToOutput(QString("Vector size: %1").arg(vectorSize));
 166 |         appendToOutput(QString("Chunk size: %1 (numThreads: %2)").arg(chunkSize).arg(numThreads));
 167 | 
 168 |         for (int i = 0; i < numThreads; i++) {
 169 |             int start = i * chunkSize;
 170 |             int end = (i == numThreads - 1) ? vectorSize : (i + 1) * chunkSize;
 171 |             if (start >= vectorSize) break;
 172 |             end = std::min(end, vectorSize);
 173 |             if (start >= end) continue;
 174 | 
 175 |             SortTask* task = new SortTask(data, start, end, i);
 176 |             m_pool->start(task);
 177 |         }
 178 | 
 179 |         while (!m_pool->waitForDone(100)) {
 180 |             QApplication::processEvents();
 181 |         }
 182 | 
 183 |         appendToOutput("=== PHASE 2: Merging sorted chunks ===");
 184 |         std::vector<std::pair<int, int>> chunks;
 185 |         for (int i = 0; i < numThreads; i++) {
 186 |             int start = i * chunkSize;
 187 |             int end = (i == numThreads - 1) ? vectorSize : (i + 1) * chunkSize;
 188 |             if (start >= vectorSize) break;
 189 |             end = std::min(end, vectorSize);
 190 |             if (start >= end) continue;
 191 |             chunks.push_back({start, end});
 192 |         }
 193 | 
 194 |         int mergeTaskId = 0;
 195 |         while (chunks.size() > 1) {
 196 |             std::vector<std::pair<int, int>> newChunks;
 197 |             for (size_t i = 0; i < chunks.size(); i += 2) {
 198 |                 if (i + 1 < chunks.size()) {
 199 |                     int start1 = chunks[i].first;
 200 |                     int end1 = chunks[i].second;
 201 |                     int start2 = chunks[i + 1].first;
 202 |                     int end2 = chunks[i + 1].second;
 203 |                     MergeTask* mergeTask = new MergeTask(data, start1, end1, start2, end2, mergeTaskId++);
 204 |                     m_pool->start(mergeTask);
 205 |                     newChunks.push_back({start1, end2});
 206 |                 } else {
 207 |                     newChunks.push_back(chunks[i]);
 208 |                 }
 209 |             }
 210 |             while (!m_pool->waitForDone(100)) {
 211 |                 QApplication::processEvents();
 212 |             }
 213 |             chunks = newChunks;
 214 |         }
 215 |         appendToOutput("=== Sorting complete! ===");
 216 |     }
 217 | };
 218 | 
 219 | bool isSorted(const std::vector<int>& vec) {
 220 |     for (size_t i = 1; i < vec.size(); i++) {
 221 |         if (vec[i] < vec[i - 1]) {
 222 |             return false;
 223 |         }
 224 |     }
 225 |     return true;
 226 | }
 227 | 
 228 | void printSample(const std::vector<int>& vec, const QString& label) {
 229 |     appendToOutput(label);
 230 |     QString firstElements = "First 10 elements: ";
 231 |     int firstCount = std::min(10, (int)vec.size());
 232 |     for (int i = 0; i < firstCount; i++) {
 233 |         firstElements += QString::number(vec[i]);
 234 |         if (i < firstCount - 1) firstElements += ", ";
 235 |     }
 236 |     appendToOutput(firstElements);
 237 | 
 238 |     if (vec.empty()) return;
 239 | 
 240 |     QString lastElements = "Last 10 elements: ";
 241 |     int lastCount = std::min(10, (int)vec.size());
 242 |     for (size_t i = std::max(0, (int)vec.size() - lastCount); i < vec.size(); i++) {
 243 |         lastElements += QString::number(vec[i]);
 244 |         if (i < vec.size() - 1) lastElements += ", ";
 245 |     }
 246 |     appendToOutput(lastElements);
 247 | }
 248 | 
 249 | 
 250 | // === Task 2: String Matrix Population and Sorting ===
 251 | 
 252 | QString generateRandomString(int length) {
 253 |     const QString possibleCharacters("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
 254 |     QString randomString;
 255 |     randomString.reserve(length);
 256 |     for (int i = 0; i < length; ++i) {
 257 |         int index = QRandomGenerator::global()->bounded(possibleCharacters.length());
 258 |         randomString.append(possibleCharacters.at(index));
 259 |     }
 260 |     return randomString;
 261 | }
 262 | 
 263 | class PopulateStringRowTask : public QRunnable {
 264 | private:
 265 |     std::vector<std::vector<QString>>* m_matrix;
 266 |     int m_rowIndex;
 267 |     int m_numCols;
 268 |     int m_stringLength;
 269 | 
 270 | public:
 271 |     PopulateStringRowTask(std::vector<std::vector<QString>>* matrix, int rowIndex, int numCols, int stringLength)
 272 |         : m_matrix(matrix), m_rowIndex(rowIndex), m_numCols(numCols), m_stringLength(stringLength) {
 273 |         setAutoDelete(true);
 274 |     }
 275 | 
 276 |     void run() override {
 277 |         std::vector<QString>& row = (*m_matrix)[m_rowIndex];
 278 |         row.resize(m_numCols);
 279 |         for (int j = 0; j < m_numCols; ++j) {
 280 |             row[j] = generateRandomString(m_stringLength);
 281 |         }
 282 |     }
 283 | };
 284 | 
 285 | class SortStringRowTask : public QRunnable {
 286 | private:
 287 |     std::vector<std::vector<QString>>* m_matrix;
 288 |     int m_rowIndex;
 289 | 
 290 | public:
 291 |     SortStringRowTask(std::vector<std::vector<QString>>* matrix, int rowIndex)
 292 |         : m_matrix(matrix), m_rowIndex(rowIndex) {
 293 |         setAutoDelete(true);
 294 |     }
 295 | 
 296 |     void run() override {
 297 |         std::sort((*m_matrix)[m_rowIndex].begin(), (*m_matrix)[m_rowIndex].end());
 298 |     }
 299 | };
 300 | 
 301 | class StringMatrixProcessor {
 302 | private:
 303 |     std::vector<std::vector<QString>>* m_matrix;
 304 |     QThreadPool* m_pool;
 305 |     int m_numRows;
 306 |     int m_numCols;
 307 |     int m_stringLength;
 308 | 
 309 | public:
 310 |     StringMatrixProcessor(std::vector<std::vector<QString>>* matrix, QThreadPool* pool, int rows, int cols, int strLen)
 311 |         : m_matrix(matrix), m_pool(pool), m_numRows(rows), m_numCols(cols), m_stringLength(strLen) {}
 312 | 
 313 |     void populate() {
 314 |         appendToOutput(QString("Populating %1x%2 string matrix with %3-char strings...").arg(m_numRows).arg(m_numCols).arg(m_stringLength));
 315 |         for (int i = 0; i < m_numRows; ++i) {
 316 |             PopulateStringRowTask* task = new PopulateStringRowTask(m_matrix, i, m_numCols, m_stringLength);
 317 |             m_pool->start(task);
 318 |         }
 319 |         while (!m_pool->waitForDone(100)) { QApplication::processEvents(); }
 320 |         appendToOutput("String matrix population complete.");
 321 |     }
 322 | 
 323 |     void sortRows() {
 324 |         appendToOutput(QString("Sorting %1 rows of string matrix...").arg(m_numRows));
 325 |         for (int i = 0; i < m_numRows; ++i) {
 326 |             SortStringRowTask* task = new SortStringRowTask(m_matrix, i);
 327 |             m_pool->start(task);
 328 |         }
 329 |         while (!m_pool->waitForDone(100)) { QApplication::processEvents(); }
 330 |         appendToOutput("String matrix row sorting complete.");
 331 |     }
 332 | };
 333 | 
 334 | 
 335 | // === Task 3: Decrement Vector Elements ===
 336 | 
 337 | class PopulateDecrementVectorTask : public QRunnable {
 338 | private:
 339 |     std::vector<int>* m_data;
 340 |     int m_startIndex;
 341 |     int m_endIndex;
 342 |     int m_maxValue;
 343 | public:
 344 |     PopulateDecrementVectorTask(std::vector<int>* data, int start, int end, int maxValue)
 345 |         : m_data(data), m_startIndex(start), m_endIndex(end), m_maxValue(maxValue) {
 346 |         setAutoDelete(true);
 347 |     }
 348 |     void run() override {
 349 |         std::random_device rd;
 350 |         std::mt19937 gen(rd() ^ ( (std::mt19937::result_type)
 351 |                                  std::chrono::duration_cast<std::chrono::seconds>(
 352 |                                      std::chrono::system_clock::now().time_since_epoch()
 353 |                                  ).count() +
 354 |                                  (std::mt19937::result_type)
 355 |                                  std::hash<std::thread::id>()(std::this_thread::get_id()) ) );
 356 |         std::uniform_int_distribution<> dis(1, m_maxValue);
 357 |         for (int i = m_startIndex; i < m_endIndex; ++i) {
 358 |             (*m_data)[i] = dis(gen);
 359 |         }
 360 |     }
 361 | };
 362 | 
 363 | class DecrementChunkTask : public QRunnable {
 364 | private:
 365 |     std::vector<int>* m_data;
 366 |     int m_startIndex;
 367 |     int m_endIndex;
 368 |     QAtomicInt* m_chunkNonZeroCount; // Changed to QAtomicInt*
 369 | 
 370 | public:
 371 |     DecrementChunkTask(std::vector<int>* data, int start, int end, QAtomicInt* chunkNonZeroCount) // Changed type
 372 |         : m_data(data), m_startIndex(start), m_endIndex(end), m_chunkNonZeroCount(chunkNonZeroCount) {
 373 |         setAutoDelete(true);
 374 |     }
 375 | 
 376 |     void run() override {
 377 |         int currentNonZero = 0; // QAtomicInt operates on int
 378 |         QRandomGenerator random = QRandomGenerator::securelySeeded();
 379 | 
 380 |         for (int i = m_startIndex; i < m_endIndex; ++i) {
 381 |             if ((*m_data)[i] > 0) {
 382 |                 if (random.bounded(2) == 0) { // 50% chance
 383 |                     (*m_data)[i]--;
 384 |                 }
 385 |                 if ((*m_data)[i] > 0) {
 386 |                     currentNonZero++;
 387 |                 }
 388 |             }
 389 |         }
 390 |         m_chunkNonZeroCount->store(currentNonZero); // Use QAtomicInt API
 391 |     }
 392 | };
 393 | 
 394 | class DecrementProcessor {
 395 | private:
 396 |     std::vector<int>* m_data;
 397 |     QThreadPool* m_pool;
 398 |     int m_vectorSize;
 399 |     QVector<QAtomicInt> m_chunkNonZeroCounts; // Changed to QVector<QAtomicInt>
 400 | 
 401 | public:
 402 |     DecrementProcessor(std::vector<int>* data, QThreadPool* pool, int vectorSize)
 403 |         : m_data(data), m_pool(pool), m_vectorSize(vectorSize) {}
 404 | 
 405 |     void populateVector(int maxValue) {
 406 |         appendToOutput(QString("Populating vector of size %1 with random values up to %2 for decrement task...").arg(m_vectorSize).arg(maxValue));
 407 |         int numThreads = m_pool->maxThreadCount();
 408 |         if (numThreads == 0) { appendToOutput("Error: Thread pool has 0 threads for population."); return; }
 409 |         int chunkSize = (m_vectorSize > 0 && numThreads > 0) ? std::max(1, m_vectorSize / numThreads) : 1;
 410 | 
 411 |         for (int i = 0; i < numThreads; ++i) {
 412 |             int start = i * chunkSize;
 413 |             int end = (i == numThreads - 1) ? m_vectorSize : (i + 1) * chunkSize;
 414 |             if (start >= m_vectorSize) break;
 415 |             end = std::min(end, m_vectorSize);
 416 |             if (start >= end) continue;
 417 | 
 418 |             PopulateDecrementVectorTask* task = new PopulateDecrementVectorTask(m_data, start, end, maxValue);
 419 |             m_pool->start(task);
 420 |         }
 421 |         while (!m_pool->waitForDone(100)) { QApplication::processEvents(); }
 422 |         appendToOutput("Decrement vector population complete.");
 423 |     }
 424 | 
 425 |     qint64 decrementToZero() {
 426 |         appendToOutput("Starting decrement process...");
 427 |         QElapsedTimer timer;
 428 |         timer.start();
 429 | 
 430 |         int numThreads = m_pool->maxThreadCount();
 431 |         if (numThreads == 0) {
 432 |             appendToOutput("Error: Thread pool has 0 threads for decrementing.");
 433 |             return -1;
 434 |         }
 435 | 
 436 |         m_chunkNonZeroCounts.clear();
 437 |         // This resize call should default-construct 'numThreads' QAtomicInt objects.
 438 |         // Default construction for QAtomicInt initializes it to zero.
 439 |         m_chunkNonZeroCounts.resize(numThreads);
 440 | 
 441 | 
 442 |         int passCount = 0;
 443 |         while (true) {
 444 |             passCount++;
 445 |             long long totalNonZeroElementsInPass = 0; // Sum can be larger than int
 446 |             int chunkSize = (m_vectorSize > 0 && numThreads > 0) ? std::max(1, m_vectorSize / numThreads) : 1;
 447 | 
 448 |             for (int i = 0; i < numThreads; ++i) {
 449 |                 int start = i * chunkSize;
 450 |                 int end = (i == numThreads - 1) ? m_vectorSize : (i + 1) * chunkSize;
 451 |                 if (start >= m_vectorSize) break;
 452 |                 end = std::min(end, m_vectorSize);
 453 |                 if (start >= end) continue;
 454 | 
 455 |                 if (i < m_chunkNonZeroCounts.size()) { // QVector uses int for size and index
 456 |                     DecrementChunkTask* task = new DecrementChunkTask(m_data, start, end, &m_chunkNonZeroCounts[i]);
 457 |                     m_pool->start(task);
 458 |                 } else {
 459 |                      appendToOutput(QString("Error: Task index %1 out of bounds for m_chunkNonZeroCounts (size %2). Skipping task.")
 460 |                                .arg(i).arg(m_chunkNonZeroCounts.size()));
 461 |                 }
 462 |             }
 463 | 
 464 |             while (!m_pool->waitForDone(100)) { QApplication::processEvents(); }
 465 | 
 466 |             for (int i = 0; i < numThreads; ++i) {
 467 |                  int start = i * chunkSize;
 468 |                  if (start >= m_vectorSize) break;
 469 | 
 470 |                 if (i < m_chunkNonZeroCounts.size()) {
 471 |                    totalNonZeroElementsInPass += m_chunkNonZeroCounts[i].load(); // Use QAtomicInt API
 472 |                 }
 473 |             }
 474 | 
 475 |             appendToOutput(QString("Decrement Pass %1: %2 elements remaining > 0.").arg(passCount).arg(totalNonZeroElementsInPass));
 476 | 
 477 |             if (totalNonZeroElementsInPass == 0) {
 478 |                 break;
 479 |             }
 480 |             QApplication::processEvents();
 481 |         }
 482 | 
 483 |         qint64 elapsed = timer.elapsed();
 484 |         appendToOutput(QString("Decrement process complete. All elements are zero. Took %1 passes.").arg(passCount));
 485 |         return elapsed;
 486 |     }
 487 | };
 488 | 
 489 | 
 490 | // === MainWindow Implementation ===
 491 | MainWindow::MainWindow(QWidget* parent) : QWidget(parent) {
 492 |     setWindowTitle("Parallel Tasks Demo");
 493 |     setFixedSize(800, 700);
 494 |     g_mainWindow = this;
 495 | 
 496 |     m_sharedThreadPool = new QThreadPool(this);
 497 |     int totalCores = QThread::idealThreadCount();
 498 |     int usableCores = std::max(1, totalCores > 1 ? totalCores - 1 : 1);
 499 |     m_sharedThreadPool->setMaxThreadCount(usableCores);
 500 | 
 501 |     QVBoxLayout* mainLayout = new QVBoxLayout(this);
 502 |     statusLabel = new QLabel("Select a task to begin.");
 503 |     statusLabel->setWordWrap(true);
 504 | 
 505 |     QHBoxLayout* buttonLayout = new QHBoxLayout();
 506 |     startButton = new QPushButton("Start Number Sort (Task 1)");
 507 |     startStringMatrixButton = new QPushButton("Start String Matrix (Task 2)");
 508 |     startDecrementButton = new QPushButton("Start Decrement Task (Task 3)");
 509 |     clearButton = new QPushButton("Clear Output");
 510 | 
 511 |     buttonLayout->addWidget(startButton);
 512 |     buttonLayout->addWidget(startStringMatrixButton);
 513 |     buttonLayout->addWidget(startDecrementButton);
 514 |     buttonLayout->addStretch();
 515 |     buttonLayout->addWidget(clearButton);
 516 | 
 517 |     outputText = new QTextEdit();
 518 |     outputText->setReadOnly(true);
 519 |     outputText->setFont(QFont("Courier", 9));
 520 | 
 521 |     mainLayout->addWidget(statusLabel);
 522 |     mainLayout->addLayout(buttonLayout);
 523 |     mainLayout->addWidget(outputText, 1);
 524 | 
 525 |     connect(startButton, &QPushButton::clicked, this, &MainWindow::runSortingDemo);
 526 |     connect(startStringMatrixButton, &QPushButton::clicked, this, &MainWindow::runStringMatrixTask);
 527 |     connect(startDecrementButton, &QPushButton::clicked, this, &MainWindow::runDecrementTask);
 528 |     connect(clearButton, &QPushButton::clicked, this, &MainWindow::clearOutput);
 529 | 
 530 |     appendToOutput(QString("GUI Application started. Shared thread pool configured with %1 max threads.").arg(usableCores));
 531 |     appendToOutput(QString("System has %1 ideal cores.").arg(totalCores));
 532 | }
 533 | 
 534 | MainWindow::~MainWindow() {
 535 |     g_mainWindow = nullptr;
 536 | }
 537 | 
 538 | void MainWindow::appendOutput(const QString& text) {
 539 |     QMetaObject::invokeMethod(this, [this, text]() {
 540 |         outputText->append(text);
 541 |         outputText->ensureCursorVisible();
 542 |     }, Qt::QueuedConnection);
 543 | }
 544 | 
 545 | void MainWindow::clearOutput() {
 546 |     outputText->clear();
 547 |     appendOutput("Output cleared. Ready for next demo!");
 548 | }
 549 | 
 550 | void MainWindow::runSortingDemo() {
 551 |     startButton->setEnabled(false);
 552 |     startStringMatrixButton->setEnabled(false);
 553 |     startDecrementButton->setEnabled(false);
 554 |     statusLabel->setText("Task 1 (Number Sort) in progress... Watch output.");
 555 |     appendOutput("\n" + QString("=").repeated(60));
 556 |     appendOutput("STARTING TASK 1: PARALLEL NUMBER SORTING DEMO");
 557 |     appendOutput(QString("=").repeated(60));
 558 | 
 559 |     data.resize(VECTOR_SIZE);
 560 |     appendToOutput(QString("Generating %1 random integers using shared pool...").arg(VECTOR_SIZE));
 561 | 
 562 |     int numGenThreads = m_sharedThreadPool->maxThreadCount();
 563 |     if (numGenThreads == 0) {
 564 |         appendToOutput("Error: Cannot generate numbers, pool has 0 threads.");
 565 |         startButton->setEnabled(true);
 566 |         startStringMatrixButton->setEnabled(true);
 567 |         startDecrementButton->setEnabled(true);
 568 |         statusLabel->setText("Error: Thread pool unavailable. Select a task.");
 569 |         return;
 570 |     }
 571 |     int genChunkSize = (VECTOR_SIZE > 0 && numGenThreads > 0) ? std::max(1, VECTOR_SIZE / numGenThreads) : 1;
 572 | 
 573 |     for (int i = 0; i < numGenThreads; i++) {
 574 |         int start = i * genChunkSize;
 575 |         int end = (i == numGenThreads - 1) ? VECTOR_SIZE : (i + 1) * genChunkSize;
 576 |         if (start >= VECTOR_SIZE) break;
 577 |         end = std::min(end, (int)VECTOR_SIZE);
 578 |         if (start >= end) continue;
 579 |         RandomGenTask* genTask = new RandomGenTask(&data, start, end);
 580 |         m_sharedThreadPool->start(genTask);
 581 |     }
 582 |     while (!m_sharedThreadPool->waitForDone(100)) { QApplication::processEvents(); }
 583 | 
 584 |     printSample(data, "\nOriginal vector (unsorted):");
 585 | 
 586 |     QElapsedTimer timer;
 587 |     timer.start();
 588 | 
 589 |     ParallelSorter sorter(&data, m_sharedThreadPool);
 590 |     sorter.parallelSort();
 591 | 
 592 |     qint64 parallelTime = timer.elapsed();
 593 |     bool sorted = isSorted(data);
 594 |     appendOutput(QString("\nVector is sorted: %1").arg(sorted ? "true" : "false"));
 595 |     printSample(data, "\nSorted vector:");
 596 |     appendOutput(QString("\nParallel sort took: %1 ms").arg(parallelTime));
 597 | 
 598 |     appendOutput("\nNow testing single-threaded sort for comparison...");
 599 |     appendOutput("Regenerating random data using shared pool...");
 600 | 
 601 |     for (int i = 0; i < numGenThreads; i++) {
 602 |         int start = i * genChunkSize;
 603 |         int end = (i == numGenThreads - 1) ? VECTOR_SIZE : (i + 1) * genChunkSize;
 604 |         if (start >= VECTOR_SIZE) break;
 605 |         end = std::min(end, (int)VECTOR_SIZE);
 606 |         if (start >= end) continue;
 607 |         RandomGenTask* genTask = new RandomGenTask(&data, start, end);
 608 |         m_sharedThreadPool->start(genTask);
 609 |     }
 610 |     while (!m_sharedThreadPool->waitForDone(100)) { QApplication::processEvents(); }
 611 | 
 612 |     timer.restart();
 613 |     std::sort(data.begin(), data.end());
 614 |     qint64 singleThreadTime = timer.elapsed();
 615 |     appendOutput(QString("Single-threaded sort took: %1 ms").arg(singleThreadTime));
 616 | 
 617 |     if (parallelTime > 0) {
 618 |         double speedup = (double)singleThreadTime / parallelTime;
 619 |         appendOutput(QString("Speedup: %1x").arg(speedup, 0, 'f', 2));
 620 |     } else {
 621 |         appendOutput("Speedup: N/A (Parallel time was zero or negative)");
 622 |     }
 623 | 
 624 |     appendOutput(QString("=").repeated(60));
 625 |     appendOutput("TASK 1 (NUMBER SORT) COMPLETE");
 626 |     appendOutput(QString("=").repeated(60) + "\n");
 627 | 
 628 |     statusLabel->setText("Task 1 complete! Select a task to begin.");
 629 |     startButton->setEnabled(true);
 630 |     startStringMatrixButton->setEnabled(true);
 631 |     startDecrementButton->setEnabled(true);
 632 | }
 633 | 
 634 | void MainWindow::printStringMatrixSample(const QString& label) {
 635 |     appendToOutput(label);
 636 |     if (stringData.empty()) {
 637 |         appendToOutput("String matrix is empty.");
 638 |         return;
 639 |     }
 640 | 
 641 |     for (int i = 0; i < std::min((int)stringData.size(), 3); ++i) {
 642 |         QString rowStr = QString("Row %1 (first 5 elements): ").arg(i);
 643 |         if (stringData[i].empty()) {
 644 |             rowStr += "[empty]";
 645 |         } else {
 646 |             for (int j = 0; j < std::min((int)stringData[i].size(), 5); ++j) {
 647 |                 rowStr += stringData[i][j];
 648 |                 if (j < std::min((int)stringData[i].size(), 5) - 1) rowStr += ", ";
 649 |             }
 650 |         }
 651 |         appendToOutput(rowStr);
 652 |     }
 653 | }
 654 | 
 655 | void MainWindow::runStringMatrixTask() {
 656 |     startButton->setEnabled(false);
 657 |     startStringMatrixButton->setEnabled(false);
 658 |     startDecrementButton->setEnabled(false);
 659 |     statusLabel->setText("Task 2 (String Matrix) in progress... Watch output.");
 660 |     appendOutput("\n" + QString("=").repeated(60));
 661 |     appendOutput("STARTING TASK 2: STRING MATRIX POPULATION AND SORT");
 662 |     appendOutput(QString("=").repeated(60));
 663 | 
 664 |     stringData.assign(STRING_MATRIX_ROWS, std::vector<QString>());
 665 | 
 666 |     StringMatrixProcessor processor(&stringData, m_sharedThreadPool, STRING_MATRIX_ROWS, STRING_MATRIX_COLS, STRING_LENGTH);
 667 | 
 668 |     QElapsedTimer timer;
 669 |     timer.start();
 670 | 
 671 |     processor.populate();
 672 |     qint64 populateTime = timer.elapsed();
 673 |     appendToOutput(QString("String matrix population took: %1 ms").arg(populateTime));
 674 |     printStringMatrixSample("\nSample of populated string matrix (before sort):");
 675 | 
 676 |     timer.restart();
 677 |     processor.sortRows();
 678 |     qint64 sortTime = timer.elapsed();
 679 |     appendToOutput(QString("String matrix row sorting took: %1 ms").arg(sortTime));
 680 |     printStringMatrixSample("\nSample of sorted string matrix:");
 681 | 
 682 |     qint64 totalTime = populateTime + sortTime;
 683 |     appendToOutput(QString("\nTotal time for Task 2: %1 ms").arg(totalTime));
 684 | 
 685 |     appendOutput(QString("=").repeated(60));
 686 |     appendOutput("TASK 2 (STRING MATRIX) COMPLETE");
 687 |     appendOutput(QString("=").repeated(60) + "\n");
 688 | 
 689 |     statusLabel->setText("Task 2 complete! Select a task to begin.");
 690 |     startButton->setEnabled(true);
 691 |     startStringMatrixButton->setEnabled(true);
 692 |     startDecrementButton->setEnabled(true);
 693 | }
 694 | 
 695 | bool MainWindow::verifyAllZero(const std::vector<int>& vec) {
 696 |     for (int val : vec) {
 697 |         if (val != 0) return false;
 698 |     }
 699 |     return true;
 700 | }
 701 | 
 702 | void MainWindow::runDecrementTask() {
 703 |     startButton->setEnabled(false);
 704 |     startStringMatrixButton->setEnabled(false);
 705 |     startDecrementButton->setEnabled(false);
 706 |     statusLabel->setText("Task 3 (Decrement Vector) in progress... Watch output.");
 707 |     appendOutput("\n" + QString("=").repeated(60));
 708 |     appendOutput("STARTING TASK 3: DECREMENT VECTOR ELEMENTS TO ZERO");
 709 |     appendOutput(QString("=").repeated(60));
 710 | 
 711 |     data.assign(DECREMENT_VECTOR_SIZE, 0);
 712 | 
 713 |     DecrementProcessor processor(&data, m_sharedThreadPool, DECREMENT_VECTOR_SIZE);
 714 | 
 715 |     processor.populateVector(MAX_RANDOM_VALUE_DECREMENT);
 716 |     printSample(data, "\nInitial vector for decrement task (first/last 10 elements):");
 717 | 
 718 |     qint64 decrementTime = processor.decrementToZero();
 719 | 
 720 |     if (decrementTime >= 0) {
 721 |         appendToOutput(QString("\nTotal time for decrement phase: %1 ms").arg(decrementTime));
 722 |         bool allZero = verifyAllZero(data);
 723 |         appendToOutput(QString("Verification: All elements are zero = %1").arg(allZero ? "true" : "false"));
 724 |         if (!allZero) {
 725 |              printSample(data, "\nSample of vector after decrement (if not all zero):");
 726 |         }
 727 |     } else {
 728 |         appendToOutput("\nDecrement task failed or was interrupted.");
 729 |     }
 730 | 
 731 |     appendOutput(QString("=").repeated(60));
 732 |     appendOutput("TASK 3 (DECREMENT VECTOR) COMPLETE");
 733 |     appendOutput(QString("=").repeated(60) + "\n");
 734 | 
 735 |     statusLabel->setText("Task 3 complete! Select a task to begin.");
 736 |     startButton->setEnabled(true);
 737 |     startStringMatrixButton->setEnabled(true);
 738 |     startDecrementButton->setEnabled(true);
 739 | }
#

# === mainwindow.h ===
   1 | #ifndef MAINWINDOW_H
   2 | #define MAINWINDOW_H
   3 | 
   4 | #include <QWidget>
   5 | #include <vector>
   6 | #include <QMutex> // For outputMutex member
   7 | 
   8 | // Forward declarations
   9 | class QLabel;
  10 | class QPushButton;
  11 | class QTextEdit;
  12 | class QThreadPool;
  13 | 
  14 | class MainWindow : public QWidget
  15 | {
  16 |     Q_OBJECT
  17 | 
  18 | public:
  19 |     MainWindow(QWidget *parent = nullptr);
  20 |     ~MainWindow();
  21 | 
  22 |     // Thread-safe method to append text to the output
  23 |     void appendOutput(const QString& text);
  24 | 
  25 |     // Public constants that other classes can access
  26 |     static const int VECTOR_SIZE = 10000000; // Original 100000000, reduced for quicker demo
  27 |     static const int USE_PCT_CORE = 80;      // Use 80% of each core's capacity
  28 | 
  29 |     // Constants for Task 2 (String Matrix)
  30 |     static const int STRING_MATRIX_ROWS = 5000;
  31 |     static const int STRING_MATRIX_COLS = 500;
  32 |     static const int STRING_LENGTH = 4;
  33 | 
  34 |     // Constants for Task 3 (Decrement Vector)
  35 |     static const int DECREMENT_VECTOR_SIZE = 5000000;
  36 |     static const int MAX_RANDOM_VALUE_DECREMENT = 50;
  37 | 
  38 | private slots:
  39 |     void runSortingDemo();
  40 |     void runStringMatrixTask();
  41 |     void runDecrementTask();
  42 |     void clearOutput();
  43 | 
  44 | private:
  45 |     QLabel* statusLabel;
  46 |     QPushButton* startButton;
  47 |     QPushButton* startStringMatrixButton;
  48 |     QPushButton* startDecrementButton;
  49 |     QPushButton* clearButton;
  50 |     QTextEdit* outputText;
  51 | 
  52 |     std::vector<int> data; // Used by Task 1 (Original Sort) and Task 3 (Decrement)
  53 |     std::vector<std::vector<QString>> stringData; // Used by Task 2
  54 | 
  55 |     QThreadPool* m_sharedThreadPool;
  56 |     QMutex outputMutex; // Although appendOutput uses QMetaObject, having a general purpose one if needed
  57 | 
  58 |     // Helper private methods
  59 |     void printStringMatrixSample(const QString& label);
  60 |     bool verifyAllZero(const std::vector<int>& vec);
  61 | };
  62 | 
  63 | #endif // MAINWINDOW_H
#

